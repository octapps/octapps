## Copyright (C) 2015 Karl Wette
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with with program; see the file COPYING. If not, write to the
## Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
## MA  02111-1307  USA

## -*- texinfo -*-
## @deftypefn {Function File} {} makeCondorRescueDAG ( @var{opt}, @var{val}, @dots{} )
##
## Build a rescue Condor DAG to rerun jobs with missing or corrupt result files.
##
## @heading Options
##
## @table @code
## @item dag_name
## Name of Condor DAG, used to name DAG submit file.
##
## @item check_load
## If true, check that result file can be loaded and
## its contents are not corrupted; otherwise, just
## check that result file exists [default: true].
##
## @end table
##
## @end deftypefn

function makeCondorRescueDAG(varargin)

  ## parse options
  parseOptions(varargin,
               {"dag_name", "char"},
               {"check_load", "logical,scalar", true},
               []);

  ## load job node data
  dag_nodes_file = strcat(dag_name, "_nodes.bin.gz");
  printf("%s: loading '%s' ...", funcName, dag_nodes_file);
  load(fullfile(".", dag_nodes_file));
  assert(isstruct(job_nodes), "%s: 'job_nodes' is not a struct", funcName);
  printf(" done\n");

  ## which jobs need to be re-run?
  rerun = false(1, length(job_nodes));

  ## iterate over jobs
  prog = [];
  for n = 1:length(job_nodes)

    ## load job node results, marking missing/corrupted jobs for rerunning
    node_result_file = glob(fullfile(job_nodes(n).dir, "stdres.*"));
    if size(node_result_file, 1) < 1
      printf("%s: rerunning job node '%s'; no result file\n", funcName, job_nodes(n).name);
      rerun(n) = true;
      continue
    elseif size(node_result_file, 1) > 1
      error("%s: job node directory '%s' contains multiple result files", funcName, job_nodes(n).dir);
    endif
    if check_load
      try
        node_results = load(node_result_file{1});
      catch
        printf("%s: rerunning job node '%s'; could not open result file\n", funcName, job_nodes(n).name);
        rerun(n) = true;
        continue
      end_try_catch
      try
        assert(isfield(node_results, "arguments"));
        assert(isfield(node_results, "results"));
        assert(isfield(node_results, "cpu_time"));
        assert(isfield(node_results, "wall_time"));
      catch
        printf("%s: rerunning job node '%s'; result file appears to be corrupted\n", funcName, job_nodes(n).name);
        rerun(n) = true;
        continue
      end_try_catch
    endif

    ## print progress
    prog = printProgress(prog, n, length(job_nodes));

  endfor

  ## if there are no jobs to be rerun, we are done
  if !any(rerun)
    printf("%s: all jobs in DAG '%s' have valid result files, not generating rescue DAG", funcName, dag_name);
    return
  endif

  ## open temporary rescue DAG file
  tmp_rescue_dag_name = strcat(dag_name, ".make_condor_rescue_dag");
  fid = fopen(tmp_rescue_dag_name, "w");
  assert(fid >= 0, "%s: could not open '%s'", funcName, tmp_rescue_dag_name);
  fprintf(fid, "# generated by %s() from %s\n\n", funcName, dag_nodes_file);

  ## print name of jobs which are being rerun
  for n = find(rerun)
    fprintf(fid, "# rerunning %s\n", job_nodes(n).name);
  endfor
  fprintf(fid, "\n");

  ## print Condor DONE commands for jobs which should NOT be rerun
  for n = find(!rerun)
    fprintf(fid, "DONE %s\n", job_nodes(n).name);
  endfor

  ## close rescue DAG
  fclose(fid);

  ## try to find a vacant rescue DAG name
  for i = 1:999
    rescue_dag_name = sprintf("%s.dag.rescue%03i", dag_name, i);
    if exist(rescue_dag_name, "file") == 0
      [err, msg] = rename(tmp_rescue_dag_name, rescue_dag_name);
      assert(err == 0, "%s: could not rename '%s' to '%s': %s", funcName, tmp_rescue_dag_name, rescue_dag_name, msg);
      printf("%s: rescue DAG for '%s' written to '%s'\n", funcName, dag_name, rescue_dag_name);
      return
    endif
  endfor
  error("%s: could not find a vacant rescue DAG name for '%s'", funcName, dag_name);

endfunction

%!test disp("no test exists for this function as it requires access to an HTCondor computer cluster")
